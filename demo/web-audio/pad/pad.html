<body>
    <div class="loading">
        <p>Loading...</p>
    </div>
    <div id="sequencer">
        <section class="controls-main">
            <h1>ModemDN</h1>
            <label for="bpm">BPM</label>
            <input name="bpm" id="bpm" type="range" min="60" max="180" value="120" step="1" />
            <span id="bpmval">120</span>
            <button data-playing="false">Play</button>
        </section>
    
        <div id="tracks">
            <!-- track one: bleep -->
            <section class="track-one">
                <h2>Sweep</h2>
                <section class="controls">
                    <label for="attack">Att</label>
                    <input name="attack" id="attack" type="range" min="0" max="1" value="0.2" step="0.1" />
                    <label for="release">Rel</label>
                    <input name="release" id="release" type="range" min="0" max="1" value="0.5" step="0.1" />
                </section>
                <!--
    
            -->
                <section class="pads">
                    <button role="switch" aria-checked="false"><span>Voice 1, Note 1</span></button>
                    <button role="switch" aria-checked="false"><span>Voice 1, Note 2</span></button>
                    <button role="switch" aria-checked="false"><span>Voice 1, Note 3</span></button>
                    <button role="switch" aria-checked="false"><span>Voice 1, Note 4</span></button>
                </section>
            </section>
    
            <!-- track two: pad/sweep -->
            <section class="track-two">
                <h2>Pulse</h2>
                <section class="controls">
                    <label for="hz">Hz</label>
                    <input name="hz" id="hz" type="range" min="660" max="1320" value="880" step="1" />
                    <label for="lfo">LFO</label>
                    <input name="lfo" id="lfo" type="range" min="20" max="40" value="30" step="1" />
                </section>
                <!--
    
            -->
                <section class="pads">
                    <button role="switch" aria-checked="false"><span>Voice 2, Note 1</span></button>
                    <button role="switch" aria-checked="false"><span>Voice 2, Note 2</span></button>
                    <button role="switch" aria-checked="false"><span>Voice 2, Note 3</span></button>
                    <button role="switch" aria-checked="false"><span>Voice 2, Note 4</span></button>
                </section>
            </section>
    
            <!-- track three: noise -->
            <section class="track-three">
                <h2>Noise</h2>
                <section class="controls">
                    <label for="duration">Dur</label>
                    <input name="duration" id="duration" type="range" min="0" max="2" value="1" step="0.1" />
                    <label for="band">Band</label>
                    <input name="band" id="band" type="range" min="400" max="1200" value="1000" step="5" />
                </section>
                <!--
    
            -->
                <section class="pads">
                    <button role="switch" aria-checked="false"><span>Voice 3, Note 1</span></button>
                    <button role="switch" aria-checked="false"><span>Voice 3, Note 2</span></button>
                    <button role="switch" aria-checked="false"><span>Voice 3, Note 3</span></button>
                    <button role="switch" aria-checked="false"><span>Voice 3, Note 4</span></button>
                </section>
            </section>
    
            <!-- track four: drill -->
            <section class="track-four">
                <h2>DTMF</h2>
                <section class="controls">
                    <label for="rate">Rate</label>
                    <input name="rate" id="rate" type="range" min="0.1" max="2" value="1" step="0.1" />
                </section>
                <!--
    
            -->
                <section class="pads">
                    <button role="switch" aria-checked="false"><span>Voice 4, Note 1</span></button>
                    <button role="switch" aria-checked="false"><span>Voice 4, Note 2</span></button>
                    <button role="switch" aria-checked="false"><span>Voice 4, Note 3</span></button>
                    <button role="switch" aria-checked="false"><span>Voice 4, Note 4</span></button>
                </section>
            </section>
        </div>
    </div><!-- sequencer -->
</body>

<script src="wavetable.js"></script>
<script>
    audioContext = new window.AudioContext()

    tempo = 60.0
    bpmControl = document.querySelector('#bpm')
    bpmValEl = document.querySelector('#bpmval')

    bpmControl.addEventListener('input', ev => {
        tempo = Number(ev.target.value)
        bpmValEl.innerText = tempo
    }, false)

    allPadButtons = document.querySelectorAll('#tracks button')

    // switch aria attribute on click
    allPadButtons.forEach(el => {
        el.addEventListener('click', () => {
            if (el.getAttribute('aria-checked') === 'false') {
                el.setAttribute('aria-checked', 'true')
                el.setAttribute('style', 'color:red')
            } else {
                el.setAttribute('aria-checked', 'false')
                el.setAttribute('style', 'color:black')
            }
        }, false)
    })

    currentNote = 0
    nextNoteTime = 0.0 // when the next note is due.

    pads = document.querySelectorAll('.pads')
    notesInQueue = []
    function scheduleNote(beatNumber, time) {
        // push the note on the queue, even if we're not playing.
        notesInQueue.push({ note: beatNumber, time: time })

        if (pads[0].querySelectorAll('button')[currentNote].getAttribute('aria-checked') === 'true') {
            // console.log('playSweep()')
            playSweep()
        }
        if (pads[1].querySelectorAll('button')[currentNote].getAttribute('aria-checked') === 'true') {
            //console.log('playPulse()')
            playPulse()
        }
        if (pads[2].querySelectorAll('button')[currentNote].getAttribute('aria-checked') === 'true') {
            // console.log('playNoise()')
            playNoise()
        }
        if (pads[3].querySelectorAll('button')[currentNote].getAttribute('aria-checked') === 'true') {
            //console.log('playSourceNode(audioContext, sample)')
            playSample(audioContext, dtmf)
        }
    }

    lookahead = 25.0 // How frequently to call scheduling function (in milliseconds)
    scheduleAheadTime = 0.1 // How far ahead to schedule audio (sec)

    function scheduler() {
        // while there are notes that will need to play before the next interval, schedule them and advance the pointer.
        while (nextNoteTime < audioContext.currentTime + scheduleAheadTime) {
            scheduleNote(currentNote, nextNoteTime)
            nextNote()
        }
        timerID = window.setTimeout(scheduler, lookahead)
    }

    function nextNote() {
        secondsPerBeat = 60.0 / tempo

        nextNoteTime += secondsPerBeat // Add beat length to last beat time

        // Advance the beat number, wrap to zero
        currentNote++
        if (currentNote === 4) {
            currentNote = 0
        }
    }

    lastNoteDrawn = 3

    function draw() {
        drawNote = lastNoteDrawn
        currentTime = audioContext.currentTime

        while (notesInQueue.length && notesInQueue[0].time < currentTime) {
            drawNote = notesInQueue[0].note
            notesInQueue.splice(0, 1)   // remove note from queue
        }

        // We only need to draw if the note has moved.
        if (lastNoteDrawn != drawNote) {
            pads.forEach(function (el, i) {
                el.children[lastNoteDrawn].style.borderColor = 'hsla(0, 0%, 10%, 1)'
                el.children[drawNote].style.borderColor = 'hsla(49, 99%, 50%, 1)'
            })
            lastNoteDrawn = drawNote
        }
        // set up to draw again
        requestAnimationFrame(draw)
    }

    periodicWave = audioContext.createPeriodicWave(wavetable.real, wavetable.imag)

    sweepLength = 2
    function playSweep() {
        oscillatorNode = audioContext.createOscillator()
        oscillatorNode.setPeriodicWave(periodicWave)
        oscillatorNode.frequency.value = 440

        gainNode = audioContext.createGain()
        gainNode.gain.cancelScheduledValues(audioContext.currentTime)
        gainNode.gain.setValueAtTime(0, audioContext.currentTime)
        // set our attack
        gainNode.gain.linearRampToValueAtTime(1, audioContext.currentTime + attackTime)
        // set our release
        gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + sweepLength - releaseTime)

        oscillatorNode.connect(gainNode).connect(audioContext.destination)
        oscillatorNode.start()
        oscillatorNode.stop(audioContext.currentTime + sweepLength)
    }

    attackTime = 0.2
    attackControl = document.querySelector('#attack')
    attackControl.addEventListener('input', function () {
        attackTime = Number(this.value)
    }, false)

    releaseTime = 0.5
    releaseControl = document.querySelector('#release')
    releaseControl.addEventListener('input', function () {
        releaseTime = Number(this.value)
    }, false)

    pulseHz = 880
    hzControl = document.querySelector('#hz')
    hzControl.addEventListener('input', function () {
        pulseHz = Number(this.value)
        // playPulse()
    }, false)

    lfoHz = 30
    lfoControl = document.querySelector('#lfo')
    lfoControl.addEventListener('input', function () {
        lfoHz = Number(this.value)
        // playPulse()
    }, false)

    pulseTime = 1
    function playPulse() {
        oscillatorNode = audioContext.createOscillator()
        oscillatorNode.type = 'sine'
        oscillatorNode.frequency.setValueAtTime(pulseHz, audioContext.currentTime)

        oscillatorNodeLFO = audioContext.createOscillator()
        oscillatorNodeLFO.type = 'square'
        oscillatorNodeLFO.frequency.setValueAtTime(lfoHz, audioContext.currentTime)

        gainNodeAMP = audioContext.createGain()
        gainNodeAMP.gain.setValueAtTime(1, audioContext.currentTime)

        oscillatorNodeLFO.connect(gainNodeAMP.gain)
        oscillatorNode.connect(gainNodeAMP).connect(audioContext.destination)
        oscillatorNodeLFO.start()
        oscillatorNode.start()
        oscillatorNode.stop(audioContext.currentTime + pulseTime)
    }

    noiseDuration = 1
    durControl = document.querySelector('#duration')
    durControl.addEventListener('input', function () {
        noiseDuration = Number(this.value)
        // playNoise()
    }, false)

    bandHz = 1000
    bandControl = document.querySelector('#band')
    bandControl.addEventListener('input', function () {
        bandHz = Number(this.value)
        // playNoise()
    }, false)

    function playNoise() {
        noiseLength = noiseDuration

        bufferSize = audioContext.sampleRate * noiseLength
        buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate)

        data = buffer.getChannelData(0) // get data

        // fill the buffer with noise
        for (i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1
        }

        sourceNode = audioContext.createBufferSource()
        sourceNode.buffer = buffer

        biquadFilterNode = audioContext.createBiquadFilter()
        biquadFilterNode.type = 'bandpass'
        biquadFilterNode.frequency.value = bandHz

        sourceNode.connect(biquadFilterNode).connect(audioContext.destination)
        sourceNode.start()
    }

    playbackRate = 1
    rateControl = document.querySelector('#rate')
    rateControl.addEventListener('input', function () {
        playbackRate = Number(this.value)
    }, false)

    loadingEl = document.querySelector('.loading')
    playButton = document.querySelector('[data-playing]')
    isPlaying = false

    setupSample()
        .then((sample) => {
            loadingEl.style.display = 'none'

            dtmf = sample // to be used in our playSample function
            playButton.addEventListener('click', function () {
                isPlaying = !isPlaying
                if (isPlaying) { // start playing
                    // check if context is in suspended state (autoplay policy)
                    if (audioContext.state === 'suspended') {
                        audioContext.resume()
                    }
                    currentNote = 0
                    nextNoteTime = audioContext.currentTime
                    scheduler() // kick off scheduling
                    draw()
                    this.dataset.playing = 'true'
                } else {
                    window.clearTimeout(timerID)
                    this.dataset.playing = 'false'
                }
            })
        })

    async function getFile(audioContext, filepath) {
        response = await fetch(filepath)
        arrayBuffer = await response.arrayBuffer()
        audioBuffer = await audioContext.decodeAudioData(arrayBuffer)
        return audioBuffer
    }

    async function setupSample() {
        filePath = 'dtmf.mp3'
        sample = await getFile(audioContext, filePath)
        return sample
    }

    function playSample(audioContext, audioBuffer) {
        sampleSource = audioContext.createBufferSource()
        sampleSource.buffer = audioBuffer
        sampleSource.playbackRate.setValueAtTime(playbackRate, audioContext.currentTime)
        sampleSource.connect(audioContext.destination)
        sampleSource.start()
        return sampleSource
    }
</script>